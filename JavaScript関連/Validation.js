// < 正規表現の練習に最適！ >
// 「Scriptular」(JS向けの動作確認サイト) => https://scriptular.com/


// 正規表現とは、、、文字列内で文字の組み合わせを照合するために用いられるパターンです。
// 1.文字の組み合わせを照合(マッチ)するために用いられるパターン
// 2.JavascriptではRegExpオブジェクトとして扱われます！ => Regular expression：レギュラーエクスプレッション(規則性のある表現)

// <正規表現を使用する場面>
// 1.入力値が正しいフォーマットかチェック！
// 2.統一のフォーマットに変換する！
// 3.URLに応じて表示する情報を切り替える！
// etc...

// 正規表現パターンの記述
// 正規表現パターンは、/abc/ のような単純な文字、または /ab*c/ や /Chapter (\d+)\.\d*/ のような単純な文字と特殊文字との組み合わせからなります。

// <正規表現の記法・書き方> => 2種類ある。

// ① リテラル記法
// <構文> let regex = /正規表現/オプション
const regex = /[^0-9]/g 
// 書き方 => /パターン/オプション

// 注意:正規表現リテラルでは「/」(スラッシュ)は正規表現パターンの「開始」と「終了」を表す予約文字である。「/」 => 正規表現パターン予約文字
// したがって、正規表現パターンに「/」を含むものには、「\」(バックスラッシュ)で「\/」こんな感じでエスケープする必要がある。
// 「\」(バックスラッシュ)も予約文字である。したがって、「\」を認識させるのには「\」を、「\\」としてエスケープする必要がある。


// ② コンストラクタ記法　=> RegExpオブジェクトのコンストラクターを経由する！
// <構文> const regex = new RegExp('正規表現','オプション');
const regex2 = new RegExp('[^0-9]','g') // 書き方 => (パターン,オプション)
// 注意:コンストラクター構文では、正規表現を文字列として指定している。

// <主なオプションフラグ>
// オプション	説明
// g	グローバルサーチ。文字列全体に対してマッチングするか（無指定の場合は1度マッチングした時点で処理を終了）
// i	大文字／小文字を区別しない（無指定の場合は区別する）
// m	複数行の入力文字列を複数行として扱う（^及び$が各行の先頭末尾にマッチする）
// u	Unicode対応（漢字などを認識してくれるようになる）


// 「メタ文字」とはアスタリスク(*)やプラス(+)などのアルファベットではない特殊な文字ことです => 「特殊文字」
// これらを正規表現で表すには、メタ文字の直前に「\」（バックスラッシュ）を付ける必要があります。
// これを「エスケープする」または「エスケープ処理」と言います。

// 「escape」 => 逃げる。免れる。脱出する。
// 正規表現における「エスケープ」とは => 特殊文字をその正規表現での役割から脱出させる。免れさせる。
// エスケープ処理を行うことによって、メタ文字の特別な意味が打ち消され、メタ文字自身を表すようになります。

// 正規表現でエスケープが必要な文字一覧 => 「特殊文字・メタ文字」一覧
// 具体的にエスケープが必要なメタ文字を記載します。

// エスケープ前	エスケープ後	注意点
// 　\ （バックスラッシュ）	　\\	エスケープを行う文字そのものなために、\ だけの記述はできません。\ を普通な文字として取り扱いたい場合は、 \\ と記述します。
// 　*（アスタリスク）	　\*	
// 　+（プラス）	　\+	
// 　.（ドット）	　\.	
// 　?（クエスチョンマーク）	　\?	
// 　^（キャレット）	　\^	行頭を指定することになります。
// 　$（ドル）	　\$	行末を指定することになります。Perl言語では、変数の先頭文字を表します。
// 　-（マイナス）	　\-	[　]の中に書く場合のみエスケープが必要
// 　|（パイプ）	　\|	
// 　/（スラッシュ）	　\/	
// 　{ or }（カーリーブラケット）	　\{	出現回数指定文字なのでエスケープが必要
// 　( or )（パーレン）	　\)	エスケープしないと後方参照が作成される。またはグループ化される。
// 　[ or ]（スクエアブラケット）	　\[	直前文字の出現回数指定文字なのでエスケープが必要
// まとめ
// このように正規表現では、メタ文字を使用することによって、複雑で高度な表現（パターン）を行うことができます。


// <正規表現で利用できる主な正規表現パターン>

// 特殊文字が何にマッチするのか？
// <文字>      <説明>                             <例>

//  ABC	   「ABC」という文字列にマッチ	   

// [ABC]    A,B,Cのいずれか１文字にマッチ	       

// [^ABC]	A,B,C以外のいずれか１文字にマッチ	      

// [A-Z]	A~Zの間の１文字	             

// \	次の文字をエスケープしてくれる。	-

// ^	行の先頭にマッチする。	/^A/　だと "BBA" の 'A' にはマッチしないが、"ABB" の 'A' にはマッチする。

// $	行の末尾にマッチする。	/A$/ だと "ABB" の 'A' にはマッチしないが、"BBA" の 'A' にはマッチする。

// *	直前の文字の０回以上の繰り返しにマッチする。	/fe* / だと "f" または "fee" にマッチ。 "eee" にはマッチしない。

// +	直前の文字の１文字以上の繰り返しにマッチする。	/fe+ / だと "fe","fee"にマッチ。"eee"にはマッチしない。

// ?	直前の文字０回か１回の出現にマッチする。	/fe? / だと"f","fe"にはマッチ。"fee"にはマッチしない。

// {n}	直前の文字をn回一致	"[0-9]{3}"は3桁の数字

// {n,}	直前の文字をn回以上と一致	"[0-9]{3,}"は３桁以上の数字

// {m,n}	直前の文字をm~n回一致	"[0-9]{3~5}"は3~5桁の数字

// .	改行文字以外のどの１文字にもマッチする。	/.n/ だと"nay an apple is on the tree"の"an","on"にはマッチする。"nay"にはマッチしない。

// \w	大文字/小文字の英字、数字、アンダースコアに一致。"[A-Za-z0-9]"と同意。	-

// \W	文字以外に一致 => "[^\w]"と同意。	-

// \d	数字に一致 => "[0-9]"と同意	 -

// \D	数字以外に一致 => "[^0-9]"と同意	  -

// \n	改行に一致	-

// \r	復帰に一致	-

// \t	タブ文字に一致	-

// \s	空白文字に一致	-

// \S	空白以外の文字に一致。"[^\s]"と同意。	-

// ~	「~」で表される文字	-


// よくある実務パターン => 郵便番号の判定！

var pattern = /^\d{3}-?\d{4}$/g; 
// ^で後に続く正規表現が、行の先頭にマッチするか？, \d は1~9の数字パターン, 直前の文字が3回出てくるパターン, -?で-が0回か1回出現するパターン, 省略・・・, $で行の末尾にマッチングするか？ ,gで文字列全体に対してマッチングするか?

var postcode = '121-4440'; //正しい郵便番号
var result = postcode.match(pattern);

["121-4440"] // result

var pattern = /^\d{3}-?\d{4}$/g;
var postcode = '121-444'; //正しくない郵便番号
var result = postcode.match(pattern);

null //result

//postcodeが正しい郵便番号だった場合はresultに代入され、正しくなかった場合はnullが代入される。


// validEmail: function (email) {
//     let re = /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
//     return re.test(email); //メールアドレスの表記のバリデーション
//   }
//   validZipaddress: function(zipaddress){
//     let re = /^\d{3}-\d{4}$/
//     return re.test(zipaddress) //郵便番号の表記のバリデーション
//   }
//   validPhone: function(phone){
//     let re = /^\d{2,5}-\d{1,4}-\d{4}$/
//     return re.test(phone) //電話番号の表記のバリデーション
//   }


const pattern = /^[0-9]/　// 入力の先頭にある文字列を示す^(キャレット) => 先頭にマッチするパターン
const str = '0123456789'
const result = str.match(pattern)

console.log(result[0]) // 0が出力 => 先頭の文字を正規表現でマッチさせるのが^

const pattern = /[0-9]$/  // 入力の末尾にある文字列を示す$
const str = '0123456789'
const result = str.match(pattern)

console.log(result[0]) // 9が出力 => 末尾の文字を正規表現でマッチさせるのが$

const pattern = /[0-9]*/  // 直前の文字に0回以上マッチする 
const str = '0123456789'
const result = str.match(pattern)

console.log(result[0]) // 0123456789

const pattern = /[0-9]*5/
const str = '0123456789'
const result = str.match(pattern)

console.log(result[0]) // 012345

const pattern = /[0-9]+/
const str = '0123456789'
const result = str.match(pattern)

console.log(result[0]) // 0123456789

const pattern = /fo*/
const str = 'fooee!!'
const result = str.match(pattern)

console.log(result[0]) // foo

const pattern = /fo*/
const str = 'fpe'
const result = str.match(pattern)

console.log(result[0]) // f

const pattern = /fo+/
const str = 'foo'
const result = str.match(pattern)

console.log(result[0]) // foo

const pattern = /fo+/
const str = 'fpo'
const result = str.match(pattern)

console.log(result[0]) // エラー




// 文字集合パターン

//  /[0-9]/ 数値（0から9のいずれか）
//  /[a-z]/ 英子文字（aからzのいずれか）
//  /[A-Z]/ 英大文字（AからZのいずれか）
//  /[a-z0-9A-Z]/ 数字・英大文字・英小文字すべてのどれか
//  /[^0-9]/ 数字ではない
// <注意ポイント> ^は[]の文字集合パターンで使用するとそれ意外と言う意味になる！


// 正規表現を使用するメソッド
// 1.matchメソッド
// 構文 str.match(pattern) //str:検索対象文字列　　pattern:正規表現

//例
let str = "ABCDEFG"
let result = str.match(/[a-c]/gi);

console.log(result); //(3) ["A", "B", "C"]
// matchメソッドは、正規パターンにマッチした文字列を配列で返す。マッチしない場合はnullを返す。gオプションを含んでる場合のみ、マッチする全てを含む配列を返します。

const pattern = /[0-9]{5}/
const str = '0123456789'
const result = str.match(pattern)

// 返り値は配列
console.log(result[0]) // 012345



// 5.replaceメソッド
// String.replaceメソッドは、正規表現でマッチした文字列を置換することができる。
// 引数repには、「$1 ~ $9」といった特殊変数を使用することができる。これらは、サブマッチ文字列を保存するための変数であり、正規表現で()で囲った文字列が順番にセットされていきます。

const telHyphen = '080-1234-5678'
const tel = telHyphen.replace(/[^0-9]/g,'') 
// gはグローバルサーチ => 発見したものすべてに対してと指定することができる！ => 今回の場合、ないと最初に発見された数値以外のみ''にしてそれ以降が処理されない。

console.log(tel) // 08012345678



// testメソッド => マッチするならtrue、マッチしないならfalseを返す！





let mail = /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;



// <よく使用するパターン>

// メールアドレス
let mail = /^([a-z0-9_\.\-])+@([a-z0-9_\.\-])+[^.]$/i

// 郵便番号
let address = /^[0-9]{3}-[0-9]{4}$/

// パスワード
let pass = /^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,}$/
// ※８文字以上の大文字小文字英数字を組み合わせたパスワード

// <電話番号>
//ハイフンあり
let tel = /^0\d{2,3}-\d{1,4}-\d{4}$/

//ハイフンなし
let tel = /^0\d{9,10}$/

//携帯番号
let tel = /^(070|080|090)-\d{4}-\d{4}$/

// 日付
// 年（YYYY）-月（MM）-日（DD）

let date = /^\d{4}-\d{1,2}-\d{1,2}$/



