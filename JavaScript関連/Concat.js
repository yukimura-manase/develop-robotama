// 配列をコピーする方法
// 配列を普通にコピーできない理由
// concatメソッドを使った配列のコピー方法について見ていきましょう！

// 配列のコピーと聞いて、次のようなコードをイメージする人もいるでしょう。

// var arr1 = [1,2,3,4,5];
// var arr2 = [];
  
// arr2 = arr1;
  
// console.log(arr1);
// console.log(arr2);
// 実行結果

// [1, 2, 3, 4, 5]
// [1, 2, 3, 4, 5]
// この例では、配列「arr1」を別の配列「arr2」に格納していますよね。

// 実行結果を見ると配列の中身がコピーされて同じ配列が作られたように見えます。

// しかし、配列というのは「参照型」のデータなので、値がコピーされていてるのではなく値が保存されているメモリの場所を共有しているだけなのです。

// そのため、次のようなコードを書くとおかしな現象になります。

// arr2.push(6);
 
// console.log(arr1);
// console.log(arr2);
// 実行結果

// [1, 2, 3, 4, 5, 6]
// [1, 2, 3, 4, 5, 6]
// これは、配列「arr2」にだけ新しい値「6」を追加しています。

// しかしながら、何も操作していない配列「arr1」も同じように値が変化しているのです。

// 理由は簡単で、どちらの配列も値が保存されている場所を参照しているだけなので、どちらかの配列でデータを変更すれば両方とも変化してしまうわけです。

// concatメソッドで配列を完全コピーする方法
// さて、配列は普通にコピーしようとするとおかしな挙動をすることが分かりましたね。

// それでは、どうやってコピーすれば良いのでしょうか？

// 実は、これまで利用してきた「concatメソッド」を使うと、この問題を簡単に解決できるのです！

// 次のサンプル例を見てください！

// var arr1 = [1,2,3,4,5];  
// var arr2 = [];
  
// arr2 = arr1.concat();
// arr2.push(6);
 
// console.log(arr1);
// console.log(arr2);
// 実行結果

// [1, 2, 3, 4, 5]
// [1, 2, 3, 4, 5, 6]
// 配列「arr2」へ別の配列をコピーするには、コピー元の「arr1」にconcat()を実行するだけで良いのです。

// concatメソッドは2つの配列を結合して1つの配列にするメソッドでしたよね？

// そのため、引数なしのconcatメソッドを実行すればコピー元の配列だけを新しく配列として返すので、結果的にコピーしているのと同じというわけです。

